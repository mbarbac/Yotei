using System.Data;

namespace Yotei.Tools.CoreGenerator;

// ========================================================
/// <summary>
/// Represents a file in a source code generation hierarchy. Files are typically associated with
/// individual types, either by they being decorated with recognized attributes, and/or because
/// their child elements.
/// </summary>
internal class FileNode : INode
{
    /// <summary>
    /// Initializes a new instance. Note that its <see cref="Node"/> property must be set
    /// before this instance can be used.
    /// </summary>
    /// <param name="compilation"></param>
    /// <param name="filename"></param>
    [SuppressMessage("", "IDE0290")]
    public FileNode(Compilation compilation, string filename)
    {
        Compilation = compilation.ThrowWhenNull();
        FileName = filename;
    }

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"File: {FileName}";

    /// <summary>
    /// The compilation captured for this instance.
    /// </summary>
    public Compilation Compilation { get; }

    /// <summary>
    /// The name of the file represented by this instance. The actual name used by the generator
    /// will be the value of this property followed by ".g.cs".
    /// </summary>
    public string FileName { get; init => field = value.NotNullNotEmpty(true); }

    /// <summary>
    /// The type node this instance is associated with.
    /// If <see langword="null"/>, then this instance is not a valid one.
    /// </summary>
    public TypeNode? Node { get; set => field = value.ThrowWhenNull(); }

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    public virtual bool Validate(
        SourceProductionContext context) => Node is not null && Node.Validate(context);

    // ----------------------------------------------------

    /// <summary>
    /// If not null, determines if the given symbol shall be considered as a valid one for chain
    /// building purposes. If null, a default criteria is used.
    /// </summary>
    protected virtual Func<ISymbol, bool>? AllowSymbolInChain { get; }

    /// <summary>
    /// If not null, determines if the given syntax shall be considered as a valid one for chain
    /// building purposes. If null, a default criteria is used.
    /// </summary>
    protected virtual Func<SyntaxNode, bool>? AllowSyntaxInChain { get; }

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cb"></param>
    //[SuppressMessage("", "IDE0019")]
    public virtual void Emit(SourceProductionContext context, CodeBuilder cb)
    {
        cb.AppendLine("// <auto-generated>");
        cb.AppendLine("#nullable enable");
        cb.AppendLine();

        if (Node is null) cb.AppendLine("// No type node available.");
        else
        {
            if (Node.SyntaxNodes.Count == 0) EmitNoSyntaxes(context, cb);
            else EmitWithSyntaxes(context, cb);
        }
    }

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to emit this file when no syntax nodes were captured. We just use a compound
    /// name as the namespace, so we need not to open and close braket indentations.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cb"></param>
    void EmitNoSyntaxes(SourceProductionContext context, CodeBuilder cb)
    {
        var nschain = Node!.Symbol
            .GetChain(AllowSymbolInChain)
            .Where(static x => x is INamespaceSymbol);
        
        var first = true;
        var sb = new StringBuilder(); foreach (var ns in nschain)
        {
            if (!first) sb.Append('.');
            sb.Append(ns.Name);
        }
        cb.AppendLine(sb.ToString());

        EmitTypeChain(context, cb);
    }

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to emit this file when there are syntax nodes captured, so we can capture and
    /// emit pragmas and usings.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cb"></param>
    [SuppressMessage("", "IDE0220")]
    void EmitWithSyntaxes(SourceProductionContext context, CodeBuilder cb)
    {
        EmitFileSyntaxHeader(context, cb);

        var nschain = Node!.SyntaxNodes[0]
            .GetChain(AllowSyntaxInChain)
            .Where(static x => x is BaseNamespaceDeclarationSyntax);

        foreach (BaseNamespaceDeclarationSyntax ns in nschain)
        {
            var name = ns.Name.ToString();
            cb.AppendLine($"namespace {name}");
            cb.AppendLine("{");
            cb.IndentLevel++;

            EmitNamespaceUsings(ns, context, cb);
        }

        EmitTypeChain(context, cb);

        foreach (BaseNamespaceDeclarationSyntax ns in nschain)
        {
            cb.IndentLevel--;
            cb.AppendLine("}");
        }
    }

    /// <summary>
    /// Invoked to emit the file pragmas and usings.
    /// </summary>
    void EmitFileSyntaxHeader(SourceProductionContext context, CodeBuilder cb)
    {
        List<string> pragmas = [];
        List<string> usings = [];
        foreach (var syntax in Node!.SyntaxNodes)
        {
            var nschain = syntax
                .GetChain(AllowSyntaxInChain)
                .Where(static x => x is BaseNamespaceDeclarationSyntax);

            PopulateFileLevelPragmas(pragmas, nschain);
            PopulateFileLevelUsings(usings, nschain);
        }

        if (pragmas.Count > 0) // File-level pragmas...
        {
            foreach (var str in pragmas) cb.AppendLine(str);
            cb.AppendLine();
        }

        if (usings.Count > 0) // File-level usings...
        {
            foreach (var str in usings) cb.AppendLine(str);
            cb.AppendLine();
        }
    }

    /// <summary>
    /// Invoked to populate the file-level pragmas.
    /// </summary>
    void PopulateFileLevelPragmas(List<string> items, IEnumerable<SyntaxNode> nschain)
    {
        foreach (var ns in nschain)
        {
            if (ns.SyntaxTree.TryGetText(out var text))
            {
                foreach (var line in text.Lines)
                {
                    var str = line.ToString().Trim();
                    if (str.StartsWith("#pragma") && !items.Contains(str)) items.Add(str);
                    else if (str.StartsWith("namespace")) break;
                }
            }
        }
    }

    /// <summary>
    /// Invoked to populate the file-level usings.
    /// </summary>
    void PopulateFileLevelUsings(List<string> items, IEnumerable<SyntaxNode> nschain)
    {
        foreach (var ns in nschain)
        {
            var comp = GetCompilation(ns);
            if (comp is null) continue;

            foreach (var item in comp.Usings)
            {
                var str = item.ToString().Trim();
                if (!string.IsNullOrWhiteSpace(str) && !items.Contains(str)) items.Add(str);
            }
        }

        // Gets the compilation unit syntax the given syntax node belongs to...
        static CompilationUnitSyntax? GetCompilation(SyntaxNode node)
        {
            while (node is not null)
            {
                if (node is CompilationUnitSyntax comp) return comp;
                node = node.Parent!;
            }
            return null;
        }
    }

    /// <summary>
    /// Invoked to emit the file-level usings.
    /// </summary>
    void EmitNamespaceUsings(
        BaseNamespaceDeclarationSyntax ns,
        SourceProductionContext context, CodeBuilder cb)
    {
        List<string> items = []; foreach (var item in ns.Usings)
        {
            var str = item.ToString().Trim();
            if (!string.IsNullOrWhiteSpace(str) && !items.Contains(str)) items.Add(str);
        }

        if (items.Count > 0)
        {
            foreach (var str in items) cb.AppendLine(str);
            cb.AppendLine();
        }
    }

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to emit this file's type chain, parent intermediate ones and the one this
    /// file is associated with.
    /// </summary>
    void EmitTypeChain(SourceProductionContext context, CodeBuilder cb)
    {
        var tpchain = Node!.Symbol.GetChain().Where(static x => x is INamedTypeSymbol).ToList();
        tpchain = tpchain.GetRange(0, tpchain.Count - 1);

        for (int i = 0; i < tpchain.Count; i++)
        {
            var type = (INamedTypeSymbol)tpchain[i];
            var head = GetHeader(type);
            cb.AppendLine(head);

            cb.AppendLine("{");
            cb.IndentLevel++;
        }

        Node.Emit(context, cb);

        for (int i = 0; i < tpchain.Count; i++)
        {
            cb.IndentLevel--;
            cb.AppendLine("}");
        }
    }

    /// <summary>
    /// Invoked to obtain the header of the given intermediate parent type.
    /// </summary>
    static string GetHeader(INamedTypeSymbol type)
    {
        var rec = type.IsRecord ? "record " : string.Empty;
        string kind = type.TypeKind switch
        {
            TypeKind.Class => "class",
            TypeKind.Struct => "struct",
            TypeKind.Interface => "interface",
            _ => throw new ArgumentException("Type kind not supported.").WithData(type.Name)
        };

        var options = new SymbolDisplayFormat(
            globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

        var name = type.ToDisplayString(options);
        return $"partial {rec}{kind} {name}";
    }
}