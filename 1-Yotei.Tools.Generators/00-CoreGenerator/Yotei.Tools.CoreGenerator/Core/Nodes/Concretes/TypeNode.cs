namespace Yotei.Tools.CoreGenerator;

// ========================================================
/// <summary>
/// Represents a type-alike node in the source code generation hierarchy.
/// </summary>
internal class TypeNode : IChildNode
{
    /// <summary>
    /// Initializes a new instance.
    /// </summary>
    /// <param name="parent"></param>
    /// <param name="symbol"></param>
    [SuppressMessage("", "IDE0290")]
    public TypeNode(INode parent, INamedTypeSymbol symbol)
    {
        Parent = parent.ThrowWhenNull();
        Symbol = symbol.ThrowWhenNull();
    }

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"Type: {Symbol.Name}";

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    public INode Parent { get; }

    /// <summary>
    /// Determines if this instance was created just to hold the child elements of the given type.
    /// If not, this instance was created because the associated type was identified as a potential
    /// candidate.
    /// </summary>
    public bool AutoGenerated { get; init; }

    /// <summary>
    /// The symbol captured for this instance.
    /// </summary>
    public INamedTypeSymbol Symbol { get; }

    /// <summary>
    /// The collection of syntax nodes captured for instance. This property can be an empty one
    /// if this information was not captured.
    /// </summary>
    public List<TypeDeclarationSyntax> SyntaxNodes { get; } = [];

    /// <summary>
    /// The collection of attributes by which this instance was found. This property can be an empty
    /// collection if this instance was created just to hold its child elements.
    /// </summary>
    public List<AttributeData> Attributes { get; } = [];

    /// <summary>
    /// The collection of child properties known to this instance.
    /// </summary>
    public List<PropertyNode> ChildProperties { get; } = [];

    /// <summary>
    /// The collection of child fields known to this instance.
    /// </summary>
    public List<FieldNode> ChildFields { get; } = [];

    /// <summary>
    /// The collection of child methods known to this instance.
    /// </summary>
    public List<MethodNode> ChildMethods { get; } = [];

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc cref="IChildNode.Augment(ICandidate)"/>
    /// </summary>
    /// <param name="candidate"></param>
    public virtual void Augment(TypeCandidate candidate)
    {
        if (candidate.Syntax is not null)
            if (SyntaxNodes.Find(x => x.IsEquivalentTo(candidate.Syntax)) == null)
                SyntaxNodes.Add(candidate.Syntax);

        foreach (var at in candidate.Attributes)
            if (Attributes.Find(x => x.EqualsTo(at)) == null)
                Attributes.Add(at);
    }
    void IChildNode.Augment(ICandidate candidate) => Augment((TypeCandidate)candidate);

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc cref="IChildNode.Augment(INode)"/>
    /// </summary>
    /// <param name="node"></param>
    public virtual void Augment(TypeNode node)
    {
        foreach (var syntax in node.SyntaxNodes)
            if (SyntaxNodes.Find(x => x.IsEquivalentTo(syntax)) == null)
                SyntaxNodes.Add(syntax);

        foreach (var at in node.Attributes)
            if (Attributes.Find(x => x.EqualsTo(at)) == null)
                Attributes.Add(at);
    }
    void IChildNode.Augment(INode node) => Augment((TypeNode)node);

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    public virtual bool Validate(SourceProductionContext context)
    {
        if (!Symbol.IsPartial) { Symbol.ReportError(CoreError.TypeNotPartial, context); return false; }
        if (!IsSupportedKind()) { Symbol.ReportError(CoreError.KindNotSupported, context); return false; }

        foreach (var node in ChildProperties) if (!node.Validate(context)) return false;
        foreach (var node in ChildFields) if (!node.Validate(context)) return false;
        foreach (var node in ChildMethods) if (!node.Validate(context)) return false;

        return true;
    }

    /// <summary>
    /// Determines if this type is of a supported kind, or not.
    /// </summary>
    /// <returns></returns>
    protected virtual bool IsSupportedKind() => Symbol.TypeKind is
        TypeKind.Class or
        TypeKind.Struct or
        TypeKind.Interface;

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cb"></param>
    public virtual void Emit(SourceProductionContext context, CodeBuilder cb) => throw null;

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to obtain the type's header, ie: 'partial {typename}'. Inheritors may override
    /// this method to add a base list, as in ': TBase, IFace, ...'.
    /// </summary>
    protected virtual string GetHeader()
    {
        var rec = Symbol.IsRecord ? "record " : string.Empty;
        string kind = Symbol.TypeKind switch
        {
            TypeKind.Class => "class",
            TypeKind.Struct => "struct",
            TypeKind.Interface => "interface",
            _ => throw new ArgumentException("Type kind not supported.").WithData(Symbol.Name)
        };

        var options = new SymbolDisplayFormat(
            globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes);

        var name = Symbol.ToDisplayString(options);
        return $"partial {rec}{kind} {name}";
    }

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to emit the source code of this type, only (ie: not the source code of its child
    /// elements).
    /// </summary>
    protected virtual void EmitCore(SourceProductionContext context, CodeBuilder cb) { }

    // ----------------------------------------------------

    /// <summary>
    /// Invoked to emit the source code of the child elements of this type.
    /// </summary>
    protected virtual void EmitChilds(SourceProductionContext context, CodeBuilder cb)
    {
        var nl = false;

        foreach (var node in ChildFields)
        {
            if (nl) cb.AppendLine(); nl = true;
            node.Emit(context, cb);
        }
        foreach (var node in ChildProperties)
        {
            if (nl) cb.AppendLine(); nl = true;
            node.Emit(context, cb);
        }
        foreach (var node in ChildMethods)
        {
            if (nl) cb.AppendLine(); nl = true;
            node.Emit(context, cb);
        }
    }
}