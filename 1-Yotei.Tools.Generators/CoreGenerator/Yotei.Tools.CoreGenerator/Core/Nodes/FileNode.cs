namespace Yotei.Tools.CoreGenerator;

// ========================================================
/// <summary>
/// Represents a file as the top-most node in a given source code generation hierarchy.
/// </summary>
internal class FileNode : INode
{
    /// <summary>
    /// Initializes a new instance.
    /// </summary>
    /// <param name="node"></param>
    [SuppressMessage("", "IDE0290")]
    public FileNode(TypeNode node) => Node = node;

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <returns><inheritdoc/></returns>
    public override string ToString() => $"File: {Node.Symbol.Name}";

    // ----------------------------------------------------

    /// <summary>
    /// The type node this file refers to.
    /// </summary>
    public TypeNode Node { get; }

    /// <summary>
    /// <inheritdoc cref="INode.Symbol"/>
    /// </summary>
    public INamedTypeSymbol Symbol => Node.Symbol;
    ISymbol INode.Symbol => Symbol;

    /// <summary>
    /// <inheritdoc cref="INode.Syntax"/>
    /// </summary>
    public TypeDeclarationSyntax? Syntax => Node.Syntax;
    SyntaxNode? INode.Syntax => Syntax;

    ImmutableArray<AttributeData> INode.Attributes => Node.Attributes;

    // ----------------------------------------------------

    /// <summary>
    /// Returns the file name associated with this instance. Inheritors must guarantee it is an
    /// unique one among the ones for a given generator. The actual file name used will be this
    /// one plus '<c>.g.cs</c>'.
    /// </summary>
    /// <returns></returns>
    public virtual string FileName()
    {
        var chain = Symbol.GetChain();
        var names = chain.Select(GetName).ToList();
        names.Reverse();
        return string.Join(".", names);

        // Invoked to the actual name for each part...
        static string GetName(ISymbol symbol)
        {
            if (symbol is not INamedTypeSymbol named || named.Arity == 0) return symbol.Name;
            else
            {
                var sb = new StringBuilder(named.Name);
                sb.Append('['); for (int i = 0; i < named.TypeArguments.Length; i++)
                {
                    if (i > 0) sb.Append(',');
                    var name = GetName(named.TypeArguments[i]);
                    sb.Append(name);
                }
                sb.Append(']');
                return sb.ToString();
            }
        }
    }

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <returns></returns>
    public virtual bool Validate(SourceProductionContext context)
    {
        var host = Symbol;
        var r = true;

        while ((host = host.ContainingType) != null)
        {
            if (!host.IsPartial)
            {
                // We report twice as the host may be in a different file, assembly, etc...
                CoreDiagnostics.TypeNotPartial(Symbol).Report(context);
                CoreDiagnostics.TypeNotPartial(host).Report(context);
                r = false;
            }
        }

        if (!Node.Validate(context)) r = false;
        return r;
    }

    // ----------------------------------------------------

    /// <summary>
    /// <inheritdoc/>
    /// </summary>
    /// <param name="context"></param>
    /// <param name="cb"></param>
    [SuppressMessage("", "IDE0019")]
    public virtual void Emit(SourceProductionContext context, CodeBuilder cb)
    {
        cb.AppendLine("// <auto-generated>");
        cb.AppendLine("#nullable enable");
        cb.AppendLine();

        if (Syntax is null) EmitNoSyntax();
        else EmitWithSyntax();

        /// <summary>
        /// Invoked when there is no syntax available, so just a compound namespace.
        /// </summary>
        void EmitNoSyntax()
        {
            var nschain = Node.Symbol.GetChain().Where(x => x is INamespaceSymbol);
            var first = true;
            var sb = new StringBuilder(); foreach (var ns in nschain)
            {
                if (!first) sb.Append('.');
                sb.Append(ns.Name);
            }
            cb.AppendLine(sb.ToString());
            EmitTypes();
        }

        /// <summary>
        /// Invoked when there is syntax available and we can find pragmas and usings.
        /// </summary>
        void EmitWithSyntax()
        {
            var nschain = Syntax.GetChain();
            EmitFileLevelPragmas(nschain);
            EmitFileLevelUsings(nschain);

            foreach (var nsitem in nschain)
            {
                var ns = nsitem as BaseNamespaceDeclarationSyntax;
                if (ns is null) continue;

                var name = ns.Name.ToString();
                cb.AppendLine($"namespace {name}");
                cb.AppendLine("{");
                cb.IndentLevel++;

                EmitNamespaceUsings(ns);
            }
            EmitTypes();

            foreach (var ns in nschain)
            {
                if (ns is not BaseNamespaceDeclarationSyntax) continue;
                cb.IndentLevel--;
                cb.AppendLine("}");
            }
        }

        /// <summary>
        /// Invoked to emit the parent types, and the one of this instance at the right level.
        /// </summary>
        void EmitTypes()
        {
            // Get the chain of intermediate parent types...
            var tpchain = Symbol.GetChain().Where(x => x is INamedTypeSymbol).ToList();
            tpchain = tpchain.GetRange(0, tpchain.Count - 1);

            // Emit them, and the one of this instance as the tail one...
            for (int i = 0; i < tpchain.Count; i++)
            {
                var tp = (INamedTypeSymbol)tpchain[i];
                var head = GetHeader(tp);
                cb.AppendLine(head);

                cb.AppendLine("{");
                cb.IndentLevel++;
            }

            Node.Emit(context, cb);

            for (int i = 0; i < tpchain.Count; i++)
            {
                cb.IndentLevel--;
                cb.AppendLine("}");
            }
        }

        /// <summary>
        /// Invoked to get the header of an intermediate parent type.
        /// </summary>
        static string GetHeader(INamedTypeSymbol type)
        {
            var rec = type.IsRecord ? "record " : string.Empty;
            var kind = type.TypeKind switch
            {
                TypeKind.Class => "class",
                TypeKind.Struct => "struct",
                TypeKind.Interface => "interface",
                _ => "<unknown>"
            };
            var options = EasyNameOptions.Default;
            var name = type.EasyName(options);
            return $"partial {rec}{kind} {name}";
        }

        /// <summary>
        /// Invoked to emit the aggregate collection of file-level pragmas.
        /// </summary>
        void EmitFileLevelPragmas(List<SyntaxNode> nschain)
        {
            List<string> items = [];
            foreach (var ns in nschain)
            {
                if (ns.SyntaxTree.TryGetText(out var text))
                {
                    foreach (var line in text.Lines)
                    {
                        var str = line.ToString().Trim();
                        if (str.StartsWith("#pragma") && !items.Contains(str)) items.Add(str);
                        else if (str.StartsWith("namespace")) break;
                    }
                }
            }
            if (items.Count > 0)
            {
                foreach (var str in items) cb.AppendLine(str);
                cb.AppendLine();
            }
        }

        /// <summary>
        /// Invoked to emit the file-level usings.
        /// </summary>
        void EmitFileLevelUsings(List<SyntaxNode> nschain)
        {
            List<string> items = [];
            foreach (var ns in nschain)
            {
                var comp = GetCompilation(ns);
                if (comp is null) continue;

                foreach (var item in comp.Usings)
                {
                    var str = item.ToString().Trim();
                    if (!string.IsNullOrWhiteSpace(str) && !items.Contains(str)) items.Add(str);
                }
            }
            if (items.Count > 0)
            {
                foreach (var str in items) cb.AppendLine(str);
                cb.AppendLine();
            }

            // Gets the compilation unit syntax the given node belongs to...
            static CompilationUnitSyntax? GetCompilation(SyntaxNode node)
            {
                while (node is not null)
                {
                    if (node is CompilationUnitSyntax comp) return comp;
                    node = node.Parent!;
                }
                return null;
            }
        }

        /// <summary>
        /// Invoked to emit the namespace-level usings.
        /// </summary>
        void EmitNamespaceUsings(BaseNamespaceDeclarationSyntax ns)
        {
            List<string> items = [];
            foreach (var item in ns.Usings)
            {
                var str = item.ToString().Trim();
                if (!string.IsNullOrWhiteSpace(str) && !items.Contains(str)) items.Add(str);
            }
            if (items.Count > 0)
            {
                foreach (var str in items) cb.AppendLine(str);
                cb.AppendLine();
            }
        }
    }
}